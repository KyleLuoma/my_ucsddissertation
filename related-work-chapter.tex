\section{Related Work for Speakql}


\paragraph{\textbf{Natural Language Interfaces}}

Section 2.2 discussed NLIs in detail and their relationship with SpeakQL. 
In particular, note that while we envision future integration of SpeakQL with NLIs for databases, the primary focus of this paper is the new dialect for spoken querying, not building a new NLI. 
We describe how our features can help improve ease of use, while preserving a context free grammar and correct-by-construction guarantees of regular SQL.
In contrast, NL-to-SQL and chat-based interfaces today are primarily aimed at NL typing-based interactions, which lack such correctness guarantees.

NLIs such as FLAME \cite{joshi2023flame} that provide code repair, autocompletion, and syntax reconstruction (i.e. inserting missing delimiter symbols) for targeted domains (spreadsheets in this case) are compelling candidates for integration with SpeakQL in a speech recognition context, where errors may result from either user or speech recognition errors.

\paragraph{\textbf{Natural Language Interfaces With Structural Elements}}

Some data NLIs straddle the line between NL and controlled NL. SODA (Search over DAta Warehouse) \cite{10.14778/2336664.2336667} employs a simple, high level, query language as input to a pattern and meta-data enabled NL-to-SQL system. 
While this system employs a formal language for input queries, it differs from SpeakQL in that 1) it does not represent the full expressive power of SQL and 2) there is not a direct mapping between the input sequence and an equivalent SQL query, and ambiguity resolution remains a challenge. 

ATHENA \cite{10.14778/2994509.2994536} is an NL-to-SQL system that employs a novel intermediate ontology query language (OQL) for disambiguation which is then translated into SQL. While the OQL is similar to SpeakQL in the sense that they are both grammar-based languages, OQL serves as an intermediate representation of NL inputs and is transparent to database users; whereas SpeakQL is the input language designed for user interaction. Additionally, OQL does not resolve NL ambiguities, and the ATHENA system generates multiple possible SQL queries for a single NL input.

NaLIR \cite{10.14778/2735461.2735468} is an NL-to-SQL system that provides an interactive communicator as a means to disambiguate NL queries that yield more than one valid SQL statement. It provides feedback to users in the form a natural language explanation of query tree-based choices and a disambiguation widget that allows users to select the correct interpretation from a list of possibilities. Similar to ATHENA, NaLIR uses a structured intermediate interpretation of an NL expression to resolve ambiguities whereas SpeakQL gives the task of disambiguation to users through its syntax structure.

\paragraph{\textbf{Speech-Based Database Interaction}}
EchoQuery~\cite{Lyons2016} is a stateful query-by-voice system that allows users to interact with a relational database in a conversational manner. 
It only presents a tool demonstration though, without a rigorous grammar or thorough user study evaluation. 
It does use a speech-friendly dialect, but its syntax represents a subset of SQL expressiveness, e.g., joins are not explicitly defined at all and disjunctive predicates are not possible at all.
In contrast, our work formalizes SpeakQL as a new dialect of SQL for spoken querying and defines its grammar.
We extend a non-trivial subset of SQL and retain its full expressive power, including on joins and predicates, because SpeakQL subsumes that SQL subset.
We also evaluate the ease of use of the SpeakQL dialect using a thorough A/B user study. 

Prior work on SpeakQL 1.0~\cite{Shah2020} is a speech+touch multimodal query interface that allows users to modify query intent using a novel SQL touch keyboard. SpeakQL 1.0 also targets a non-trivial subset of SQL. In contrast, SpeakQL 2.0 (this paper) proposes and evaluates a new dialect of SQL designed for spoken querying, not a new multimodal interface with touchscreen focus.

Data@Hand \cite{10.1145/3411764.3445421} is another speech+touch query interface that allows interaction with personal health data on a smartphone device. Users issue natural language instructions to initiate interaction, and then disambiguate or modify their requests with on-screen widgets. Data@Hand differs from other systems mentioned here as it is targeted at lay users and limited to personal health data in scope, whereas SpeakQL is targeted at SQL-trained data analysts and database experts and is intended to function on any arbitrary relational database.

CiceroDB~\cite{10.14778/3415478.3415496} uses Google Assistant to infer user query intent from NL statements and vocalizes query result sets using computer-generated voice. 
It is orthogonal to both the general goals of the SpeakQL line of work and this paper's specific goals of a new speech-first dialect of SQL. 
One can use both SpeakQL and CiceroDB together to enable fully speech-based interactions with databases to both query data and to consume results.

Setlur and Tory \cite{10.1145/3491102.3501972} design and evaluate a speech-only interaction system as well as a speech+visual multimodal interaction system for querying data and viewing results on a tablet device. Rather than using a structured, or semi-structured language, these systems employ a chatbot-style natural language interface. Among other results, the authors found that augmenting a voice-based system with visual feedback resulted in richer dialogue and data exploration sessions.

\paragraph{\textbf{Spoken Programming as Assistive Technology}}
Spoken programming systems have been considered and evaluated as assistive technologies for programmers with motor impairments. 
Much prior art in this space ended up as ultimately unconvincing due to weak ASR capabilities~\cite{1698772}. 
But the recent wave of highly accurate deep learning-based ASR has rekindled interest in this space. 
Usability interviews with motor impaired programmers suggested a promising future for an NL-based programming system that can avoid dictation of symbols and variables~\cite{10.1145/3517428.3550392}. 
The SpeakQL dialect is inspired by a similar vision and our user study survey responses support a similar conclusion, viz., a desire for more natural-feeling constructs to avoid dictating symbols.



\section{Related Work for Snails}



\paragraph{\textbf{Ontology Mapping}}
Schema modifications and intermediate representations to enhance performance in a specific context extend beyond NL-to-SQL applications.
Mapping relational database schemas to ontologies is an approach used to improve schema-to-schema integration and web application application-database interfaces~\cite{4061430}.
This improves the semantic description of underlying data, which is often a desirable feature in web applications that interact within the semantic web~\cite{7396620}.
While ontological mapping of a relational database can improve performance in this context; we see less evidence that such an approach is useful or necessary in NL-to-SQL applications, though this may serve as a compelling opportunity for future research.

\paragraph{\textbf{NL-to-SQL Benchmarks}}
\emph{Spider}~\cite{Yu&al.18c}, soon to be superseded by a more challenging benchmark for the LLM era, was a popular NL-to-SQL benchmark that still offers a publically-available dataset consisting of 166 multi-table databases and 1,034 NL questions and gold queries over the databases in a development dataset. 
\emph{Spider-Syn}~\cite{gan-etal-2021-towards} and Spider-Realistic~\cite{gan-etal-2021-towards} are extensions of the Spider benchmark that perform NL question synonym replacement to reduce the occurrences of lexical matching between NL question keywords and schema identifiers.
\emph{BIRD}~\cite{li2023llm} is an emergent benchmark containing 95 large databases over 37 domains that seeks to better replicate real-world databases in order to better challenge highly capable LLM-based NL-to-SQL systems.
While Spider and its variants as well as BIRD intend to better-replicate real-world database designs, our naturalness-focused analysis indicates that their schema identifiers are more natural than those we encountered in our real-world database selection process (see the statistics in Figure \ref{fig:naturalnesscompare}).
Additionally, Spider and BIRD both evaluate performance using either exact set matching or execution result set comparison while we use the more pragmatic set-superset matching as proposed in~\cite{floratou2024nl2sql} and schema linking-specific recall metrics.

\emph{Archerfish}
~\cite{floratou2024nl2sql} is a benchmarking framework that relaxes execution matching and accounts for semantic ambiguity in NL questions by allowing for multiple correct answers derived from candidate key analysis.
This framework relies on the binary ``correct, or not'' evaluation approach common to other benchmarks, whereas in addition to relaxed execution matching, SNAILS evaluates target schema linking performance via query identifier recall.
Overall, we find that our benchmark and findings complement this existing and ongoing research by enhancing our ability to target specific schema-related aspects of NL-to-SQL performance in future NLI development.

\paragraph{\textbf{Impacts of Schema on NL-to-SQL Performance}}
Spider-Syn~\cite{gan-etal-2021-towards} demonstrates degraded NL-to-SQL performance of language models trained for NL-to-SQL tasks when the occurrence of lexical matching between NL questions and schema identifiers is reduced. 
This approach differs from our experiments in that it evaluates a LM specifically trained on NL-to-SQL tasks using the Spider training set as opposed to the more general-purpose foundational LLMs evaluated in this work.
They also make no apparent attempt to reduce the naturalness of  database schema identifiers.

Semantics-preserving schema transformation is a design feature of MT-teql~\cite{10.14778/3494124.3494139}, an NL-to-SQL evaluation framework that modifies natural language utterances and schema properties to stress LM robustness.
MT-teql provides a holistic view of the effect of NL utterance variances and schema design on LM performance. 
However, it does not address the question of schema identifier naturalness, nor does it make modifications to schema elements that are necessary for answer generation. 

Some recent work has examined the effects of schema ambiguity, where semantically different tables or columns have identical or synonymous names.
Schema ambiguity, where a schema contains one or more semantically similar pairs of elements, degrades semantic parsing (i.e., NL-to-SQL) performance by recalling undesired tables or columns in response to a NL question that contains patterns or keywords that align with more than one schema element in the latent space~\cite{10555063}.
Documentation, combined with agent-based column selection, can improve Text-to-SQL performance in the presence of data and schema ambiguity~\cite{huang2023data}.
Though we did not focus on ambiguity in our work, identifier naturalness and ambiguity are complementary efforts that provide a potential future direction for the expansion of the SNAILS benchmark artifacts. 


\section{Related Work for Skalpel}


\paragraph{\textbf{Evaluating Schema Subsetting Methods}}
CRUSH~\cite{kothyari-etal-2023-crush4sql} is a recent work that performs subsetting evaluation of a novel halucination-based subsetting method and compares it to variations of dense passage retrieval.
The authors provide benchmark datasets including SpiderUnion, and BirdUnion--unions of the disjoint schemas in the Spider~\cite{benchmark-spider} and Bird~\cite{benchmark-bird} benchmarks respectively. They also introduce SocialDB, a collection of database schemas and schema descriptions without associated database instances and NL-SQL question-query pairs.
In our work, we extend this line of research further by adopting the  SNAILS collection to better-represent real-world schema subsetting challenges.
Additionally, we adopt a more robust benchmark evaluation strategy by introducing precision and f1 metrics in addition to the recall metric used by the CRUSH authors.
Finally, our subsetting method comparison is more representative of the current SOTA in the NL-to-SQL domain by evaluating subsetting methods described by systems with top placement on current benchmarks.

A recent ArXiv preprint that critically evaluates the usefulness of schema subsetting using SoTA LLMs suggests that as LLM capability increases, the need for schema subsetting diminishes~\cite{maamari2024deathschemalinkingtexttosql}.
In this work, the authors evaluate four LLM-based schema subsetting methods using the Bird SQL benchmark and measure performance using execution accuracy, false positive rates during subsetting, and schema linking recall.
While this concurrent work bears some resemblance to our \PROJECTNAME{ } project, we provide additional measures of recall, precision, and F1 for various combinations of table and column identifiers.
We also extend the scope of subsetting evaluation to non-LLM-based subsetting methods such as semantic similarity search- and finetuned classifier-based approaches.
In addition to the Bird benchmark, we also evaluate SoTA linking methods using the Spider2 and SNAILS benchmarks.

The authors of the \emph{In-depth Analysis of LLM-based Schema Linking}~\cite{Katsogiannis-Meimarakis2026} concurrently and independently developed a schema subsetting (or schema linking) evaluation methodology focused on LLM-based schema linking approaches in which they replicate several LLM-prompting methods for schema linking and evaluate them in terms of precision, recall, and accuracy using the Spider and Bird benchmarks~\cite{benchmark-spider,benchmark-bird}.
Our work complements this approach and makes use of the Spider 2 and SNAILS~\cite{benchmark-spider2,benchmark-snails} benchmarks which contain very large schemas.
We also opt to reproduce existing subsetting methods using original code, and additionally evaluate subsetting performance in terms of token usage as well as both online inference and offline pre-processing time requirements. 


